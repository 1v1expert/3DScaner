# -*- coding: utf-8 -*-
# This file is part of the Horus Project

__author__ = 'Jes√∫s Arroyo Torrens <jesus.arroyo@bq.com>'
__copyright__ = 'Copyright (C) 2014-2016 Mundo Reader S.L.\
                 Copyright (C) 2013 David Braam from Cura Project'
__license__ = 'GNU General Public License v2 http://www.gnu.org/licenses/gpl2.html'

"""
STL file mesh loader.
STL is the most common file format used for 3D printing right now.
STLs come in 2 flavors.
    Binary, which is easy and quick to read.
    Ascii, which is harder to read, as can come with windows, mac and unix style newlines.
    The ascii reader has been designed so it has great compatibility
    with all kinds of formats or slightly broken exports from tools.

This module also contains a function to save objects as an STL file.

http://en.wikipedia.org/wiki/STL_(file_format)
"""

import os
import struct
import numpy as np

from horus.util import model
from horus import __version__

import logging
logger = logging.getLogger(__name__)


def _load_ascii(mesh, stream):
    cnt = 0
    for lines in stream:
        for line in lines.split('\r'):
            if 'vertex' in line:
                cnt += 1
    mesh._prepare_face_count(int(cnt) / 3)
    stream.seek(5, os.SEEK_SET)
    cnt = 0
    data = [None, None, None]
    for lines in stream:
        for line in lines.split('\r'):
            if 'vertex' in line:
                data[cnt] = line.split()[1:]
                cnt += 1
                if cnt == 3:
                    mesh._add_face(float(data[0][0]), float(data[0][1]), float(data[0][2]),
                                   float(data[1][0]), float(data[1][1]), float(data[1][2]),
                                   float(data[2][0]), float(data[2][1]), float(data[2][2]))
                    cnt = 0


def _load_binary(mesh, stream):
    # Skip the header
    stream.read(80 - 5)
    count = struct.unpack('<I', stream.read(4))[0]

    dtype = np.dtype([
                    ('n', np.float32, (3,)),
                    ('v', np.float32, (9,)),
                    ('atttr', '<i2', (1,))])

    data = np.fromfile(stream, dtype=dtype, count=count)

    mesh.vertex_count = 3 * count
    n = np.zeros((mesh.vertex_count / 3, 9), np.float32)
    n[:, 0:3] = n[:, 3:6] = n[:, 6:9] = data['n']
    mesh.normal = n.reshape(mesh.vertex_count, 3)
    mesh.vertexes = np.reshape(data['v'], (mesh.vertex_count, 3))
    logger.error(mesh.vertexes.shape)

def load_scene(filename):
    obj = model.Model(filename)
    m = obj._add_mesh()
    with open(filename, "rb") as f:
        if f.read(5).lower() == "solid":
            _load_ascii(m, f)
        else:
            _load_binary(m, f)
        obj._post_process_after_load()
        return obj

def save_scene(filename, _object):
    with open(filename, 'wb') as f:
        save_scene_stream(f, _object)


def _get_triangle_normal(a, b, c): 
    return np.cross(b - a, c - a)


def _smoothing_one(last, next, current):
    return 0.5 * (next + last) - current


from scipy.spatial import Delaunay

def smoothing(meshes, times):
    triangles = Delaunay(meshes.vertexes[:, 0:2]).simplices

    for i in range(0, times):
        for j in range(1, new_mesh.shape[0] - 1, 3):
            new_mesh[j] = _smoothing_one(new_mesh[j - 1], new_mesh[j + 1], new_mesh[j])
    return new_mesh

def save_scene_stream_ply(stream, _object):
    m = _object._mesh

    binary = True

    if m is not None:
        frame = "ply\n"
        if binary:
            frame += "format binary_little_endian 1.0\n"
        else:
            frame += "format ascii 1.0\n"
        frame += "comment Generated by Horus {0}\n".format(__version__)
        frame += "element vertex {0}\n".format(m.vertex_count)
        frame += "property float x\n"
        frame += "property float y\n"
        frame += "property float z\n"
        frame += "property uchar red\n"
        frame += "property uchar green\n"
        frame += "property uchar blue\n"
        frame += "property float nx\n"
        frame += "property float ny\n"
        frame += "property float nz\n"
        frame += "element face 0\n"
        frame += "property list uchar int vertex_indices\n"
        frame += "end_header\n"
        stream.write(frame)
        if m.vertex_count > 0:
            if binary:
                for i in xrange(m.vertex_count):
                    stream.write(struct.pack("<fffBBBfff",
                                             m.vertexes[i, 0], m.vertexes[i, 1], m.vertexes[i, 2],
                                             m.colors[i, 0], m.colors[i, 1], m.colors[i, 2],
                                             m.normal[i, 0], m.normal[i, 1], m.normal[i, 2]))
            else:
                for i in xrange(m.vertex_count):
                    stream.write("{0} {1} {2} {3} {4} {5}\n".format(
                                 m.vertexes[i, 0], m.vertexes[i, 1], m.vertexes[i, 2],
                                 m.colors[i, 0], m.colors[i, 1], m.colors[i, 2]))

def save_scene_stream(stream, _object):
    mesh = _object._mesh
    #np.array([0 for i in range(80)], dtype=np.byte).tofile(stream)


#    triangles = mesh.vertexes[Delaunay(mesh.vertexes[:, 0:2]).simplices]

 #   stream.write(struct.pack("<I", triangles.shape[0]))
    mesh._compute_normals()
    save_scene_stream_ply(stream, _object)

    #smoothed_mesh = smoothing(mesh, 5)

    #for smoothed_mesh in triangles:
    #    normal = _get_triangle_normal(np.array([smoothed_mesh[0, 0], smoothed_mesh[0, 1], smoothed_mesh[0, 2]]),
    #                                  np.array([smoothed_mesh[1, 0], smoothed_mesh[1, 1], smoothed_mesh[1, 2]]),
    #                                  np.array([smoothed_mesh[2, 0], smoothed_mesh[2, 1], smoothed_mesh[2, 2]]));
    #    stream.write(struct.pack("<ffffffffffffH",
    #                             normal[0],               normal[1],               normal[2],
    #                             smoothed_mesh[0, 0], smoothed_mesh[0, 1], smoothed_mesh[0, 2],
    #                             smoothed_mesh[1, 0], smoothed_mesh[1, 1], smoothed_mesh[1, 2],
    #                             smoothed_mesh[2, 0], smoothed_mesh[2, 1], smoothed_mesh[2, 2],
    #                             0))

