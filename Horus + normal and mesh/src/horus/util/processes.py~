import subprocess
import sys
import numpy as np
import timeit


class NormalEstimation:
    def __init__(self, mesh, **args):
        assert mesh is not None
        self.neighborhood_size = args['neighborhood_size'] if 'neighborhood_size' in args.keys() else 100
        self.planes_count = args['planes_count'] if 'planes_count' in args.keys() else 1000
        self.acc_steps = args['acc_steps'] if 'acc_steps' in args.keys() else 15
        self.rotation_count = args['rotation_count'] if 'rotation_count' in args.keys() else 5
        self.tolerance_angle = args['tolerance_angle'] if 'tolerance_angle' in args.keys() else 79
        self.neighborhood_size_dens_est = args['neighborhood_size_dens_est'] \
                                          if 'neighborhood_size_dens_est' in args.keys() else 5
        self.mesh = mesh
        self.executed = False
        self._prepare()

    def _prepare(self):
        with open('input.xyz', 'w') as f:
            for vertex in self.mesh.vertexes:
                f.write('{0} {1} {2}\n'.format(vertex[0], vertex[1], vertex[2]))

    def run_and_wait(self):
        with open('input.xyz', 'r') as stdin:
            with open('output.xyz', 'w') as stdout:
                return_code = subprocess.call(["./Hough_Exec",
                                               "-k {0}".format(self.neighborhood_size),
                                               "-t {0}".format(self.planes_count),
                                               "-p {0}".format(self.acc_steps),
                                               "-r {0}".format(self.rotation_count),
                                               "-a {0}".format(self.tolerance_angle / 100),
                                               "-e {0}".format(self.neighborhood_size_dens_est)],
                                              stdin=stdin,
                                              stdout=stdout,
                                              stderr=sys.stderr)
        if return_code == 0:
            self.executed = True
        else:
            raise RuntimeError('Execution of Hough_Exec was unsuccessful: return code {0}'.format(return_code))

    def get_normals(self):
        assert self.executed
        with open('output.xyz', 'r') as f:
            lines = f.readlines()

        index_of_data = 0
        for i, line in enumerate(lines):
            if line.strip() == 'points':
                index_of_data = i + 1
                break

        return np.array([[float(value) for value in line.split()[3:]] for line in lines[index_of_data:]])

